# Developer Documentation

## Overview
This repository, "Context Suite Utilities for Data Engineering," provides a collection of tools, schemas, and libraries to facilitate the onboarding and streaming of operational data into the Context Suite. It aims to offer a centralized resource for developers working with Context Suite data integration.

## Repository Structure
The repository is organized as follows:

- **`/` (Root)**: Contains main README, this developer guide, and configuration files.
- **`cxs-schema/`**: Houses data schemas in various formats:
    - `avro/`: Apache Avro schemas (`.avsc` files). Includes a `README.md` and validation script.
    - `json-schema/`: JSON Schema definitions (`.json` files). Includes a `README.md` and validation script.
    - `pydantic/`: Pydantic models generated from the schemas. Includes validation scripts.
    - `sql/`: SQL table definitions (`.sql` files) related to the schemas. Includes a `README.md`.
- **`docs/`**: Contains a documentation website built with Next.js and Markdoc. This site likely serves as user-facing documentation for the schemas and tools.
    - `pages/docs/`: Contains the actual documentation content in Markdown.
- **`javascript/`**: Contains JavaScript/TypeScript code and related utilities.
    - `jitsu/`: Specific utilities or integrations related to Jitsu (a data collection platform).
- **`plugins/`**: Intended for plugins or extensions, currently includes an `ecommerce` plugin example.
- **`python/`**: Contains Python libraries and scripts.
    - `cxs/`: Core Python library for Context Suite, including client code and schema-related Pydantic models.

    

## Current Contents
The repository currently includes:

- **Data Schemas**: Comprehensive schemas for various data points, entities, and events in Avro and JSON Schema formats.
- **Pydantic Models**: Python Pydantic models auto-generated or corresponding to the defined schemas, useful for data validation and manipulation in Python applications.
- **SQL Definitions**: Basic SQL table structures corresponding to some of the core schemas.
- **Validation Scripts**: Python scripts to validate Avro schemas (`validate_avro_schemas.py`) and JSON schemas (`validate_json_schemas.py`), and Pydantic models (`validate_pydantic_models.py`).
- **Documentation Website**: A Next.js based website in `docs/` providing detailed information about schemas.
- **Jitsu Integration Example**: Basic JavaScript code under `javascript/jitsu/` demonstrating a Jitsu-related test or utility.
- **Python Library**: A Python library in `python/cxs/` for interacting with Context Suite, including schema handling.

## Classification Fields in Semantic Events

The Context Suite semantic events schema includes a `classification` array that contains entries for categorizing entities. This section explains key fields in classification entries.

### Core Fields

- **type**: The classification type (e.g., "Category", "Tag", "Sentiment")
- **value**: The actual classification value (e.g., "Electronics", "Winter", "Positive")

### Special Fields for ML/LLM Classification

Two special fields are available specifically for machine learning and LLM-based classification processes but are not typically present in standard semantic events:

- **reasoning**: Provides the rationale or explanation for why this classification was applied. This field is primarily used when classifications are generated by ML/LLM systems to provide transparency into their decision-making process.

- **weight**: A numerical value between 0.0 and 1.0 that indicates the confidence or importance of this classification. Higher weights (closer to 1.0) indicate higher confidence or importance. This field is useful for:
  - Storing confidence scores from ML classification systems
  - Representing hierarchical relationships in taxonomies (e.g., parent categories with lower weights, specific categories with higher weights)
  - Ranking multiple classifications by importance

### Usage Guidelines

1. For standard data integrations (non-ML), include only the `type` and `value` fields in classification entries
2. When processing data through ML/LLM systems, the `reasoning` and `weight` fields can be populated to capture the model's decision process
3. When representing hierarchical taxonomies, weights can be used to indicate depth in the hierarchy

### Example: Standard Classification

```json
"classification": [
  {
    "type": "Category",
    "value": "Snowboards"
  },
  {
    "type": "Tag",
    "value": "Winter"
  }
]
```

### Example: ML-Enhanced Classification

```json
"classification": [
  {
    "type": "Category",
    "value": "Snowboards",
    "reasoning": "Product description mentions snowboarding equipment and features",
    "weight": 0.92
  },
  {
    "type": "Sentiment",
    "value": "Positive",
    "reasoning": "Review contains positive language and 5-star rating",
    "weight": 0.87
  }
]
```

## Entity Identification in Context Suite

Context Suite uses a semantic web inspired approach for entity identification across our data model.

### Concepts

- **GID_URL**: Represents the authoritative location where an entity "resides" - inspired by RDF and semantic web principles. These are preferably real URLs that serve as the canonical identifier for an entity.

- **Entity_GID**: A UUID derived from the GID_URL using a named UUID algorithm. This provides a compact, database-friendly identifier that's consistently generated from the same URL.

### Benefits

1. **Semantic Meaning**: GID_URLs carry semantic meaning about what the entity is and where it's defined
2. **Size Efficiency**: Entity_GIDs are more compact than full URLs (just 16 bytes)
3. **Performance**: UUIDs are optimized for database operations like indexing and joining
4. **Consistency**: The same GID_URL will always generate the same Entity_GID

### How It Works

- Every `_gid` suffixed field is always a calculated value from "something meaningful"
- When you see a `_gid` field, you can know it represents a constant ID for some URL
- We sometimes have the `gid_url` explicitly, other times we create it from known unique data
- A `gid_url` always contains more semantic meaning than just timestamps or random values

### Examples

#### Shopify Product Example

For a Shopify product with ID 15100602155333:

```json
{
  "entity_gid": "550e8400-e29b-41d4-a716-446655440000", 
  "properties": {
    "gid_url": "https://shop.example.com/products/15100602155333",
    "admin_graphql_api_id": "gid://shopify/Product/15100602155333"
  }
}
```

### Implementation Notes

1. Always generate Entity_GIDs consistently from the same input GID_URL
2. When creating a new entity, establish a meaningful GID_URL that uniquely identifies it
3. For external entities, incorporate the source system and ID into the GID_URL
4. GID_URLs should follow URI format but don't necessarily need to be resolvable web URLs

## Future Direction
This section outlines the planned enhancements and future scope of this repository.
*(Note: This section requires input from the project maintainers for specific upcoming features, tools, or areas of development. Examples could include:)*
- *Expansion of schemas to cover more domains.*
- *Development of client libraries for other programming languages (e.g., Java, Go).*
- *More comprehensive CLI tools for schema management and data generation.*
- *Integration guides for more third-party platforms.*
- *Enhanced automated testing for all components.*

## Contributing
Contributions to this repository are welcome. Please refer to the `CONTRIBUTING.md` file (if available) for detailed guidelines on how to contribute. If such a file does not exist, general best practices apply:
1. Fork the repository.
2. Create a new branch for your feature or bug fix.
3. Make your changes, including tests if applicable.
4. Ensure your code lints and tests pass.
5. Submit a pull request with a clear description of your changes.
